function output = staticTrigBsplinePowerSpec(x, tc, fs, fo, ord, fftl)
% output = staticTrigBsplinePowerSpec(x, tc, fs, fo, ord, fftl)
%
% A proof of concept implementation of two staged trigonometric-spline
% interference-free spectral representation proposed in:
% Kawahara, H., Morise, M., Hua, K. (2018) Revisiting spectral envelope 
% recovery from speech sounds generated by periodic excitation, APSIPA ASC 2018, TH-P1-8.4.
%
% Argument
%   x     : imput signal. One dimensional column vector
%   tc    : Center location of the analsis window (s)
%   fs    : sampling frequency (Hz)
%   fo    : assumed fundamental frequency for analysis (Hz)
%   ord   : order of the function
%   fftl  : FFT buffer length for spectral processing
%
% Output
%   output  : structure variable with the following fields
%     wsp    : window 
%     wspd   : differentiated and weighted window
%     tt     : normalized time axis
%     xseg   : analysed signal segment
%     pwr    : power using wsp
%     pwd    : power using wspd
%     pw     : temporally interference-free spectrum
%     pws    : interference-free spectrum in the T-F plane
%     fx     : frequency axis
    

% copyright 2018 Hideki Kawahara
% Licensed under the Apache License, Version 2.0 (the "License");
% you may not use this file except in compliance with the License.
% You may obtain a copy of the License at
% 
%     http://www.apache.org/licenses/LICENSE-2.0
% 
% Unless required by applicable law or agreed to in writing, software
% distributed under the License is distributed on an "AS IS" BASIS,
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
% See the License for the specific language governing permissions and
% limitations under the License.
%
% This version is only for proof of concept

cf = [0   -2.0982  -18.0618   15.9636; ...
  1.0000   -6.0207  -12.4418    6.4211; ...
  2.0000   -9.9431  -11.9273    1.9841; ...
  3.0000  -13.8656  -12.9271   -0.9384];
to = round(fs / fo);
tt = ((1:to) - to / 2 - 0.5)';
wsp = cos(pi * tt / to);
sp0 = ones(to, 1);
switch ord
  case 0
  case 1
    tt = ((1:2 * to - 1) - to / 2 * 2 )';
    wsp = conv(sp0, wsp);
  case 2
    tt = ((1:3 * to - 2) - to / 2 * 3 + 0.5)';
    wsp = conv(sp0, conv(sp0, wsp));
  case 3
    tt = ((1:4 * to - 3) - to / 2 * 4 + 1)';
    wsp = conv(sp0, conv(sp0, conv(sp0, wsp)));
end
wsp = wsp / sum(wsp);
wdsp = wsp .* tt / to;
n = length(x);
xseg = x(max(1, min(n, round(fs * tc + tt))));
pwr = abs(fft(xseg .* wsp, fftl)) .^ 2;
pwd = abs(fft(xseg .* wdsp, fftl)) .^ 2;
pw = pwr + pwd * 10 ^ (cf(ord + 1, 4) / 10);
fx = (0:fftl - 1)' / fftl * fs;
cumpw = cumsum(pw * fx(2));
pwU = interp1([fx(fx > fs - 1000) - fs;fx] - fx(2) / 2, ...
  [cumpw(fx > fs - 1000) - cumpw(end);cumpw], ...
  fx(1:fftl / 2 + 1) + fo / 2, 'linear', 'extrap');
pwL = interp1([fx(fx > fs - 1000) - fs;fx] - fx(2) / 2, ...
  [cumpw(fx > fs - 1000) - cumpw(end);cumpw], ...
  fx(1:fftl / 2 + 1) - fo / 2, 'linear', 'extrap');
pws = (pwU - pwL) / fo;
output.wsp = wsp;
output.wspd = wdsp * 10 ^ (cf(ord + 1, 4) / 20);
output.tt = tt / to;
output.xseg = xseg;
output.pwr = pwr;
output.pwd = pwd;
output.pw = pw;
output.pws = pws;
output.fx = fx;
end
